# 例外をキャッチした時に例外の種類に応じて処理を分ける
例外がスローされる原因となるエラーにはいくつかの種類があります。
try...catch 文を使った例外処理で複数の種類の例外が発生する可能性がある場合は、スローされた例外の種類ごとに複数の catch を記述して実行する処理を分けることが可能です。

## 例外が発生するエラーの種類
例外が発生するエラーの種類として次の 8 種類がグローバルオブジェクトとして定義されています。

### Error           一般的なエラー
### EvalError       eval 関数に関するエラー
### InternalError   JavaScriptの内部エラー
### RangeError      数値が有効範囲を超えた場合のエラー
### ReferenceError  不正な参照を行った場合のエラー
### SyntaxError     JavaScriptの構文エラー
### TypeError       変数や引数の型が適切ではない場合のエラー
### URIError        encodeURIまたはdecodeURIに関するエラー
※ ただし SyntaxError は実行時にエラーとなるのではなく実行前の時点でエラーとなるため、明示的に SyntaxError オブジェクトを作成してスローしない限りは、構文ミスが理由で実行時に例外をスローすることはないと思います。

例えば Number オブジェクトの toString メソッドでは、引数に 2 から 36 までの範囲の値しか指定できませんが、それを超える値を指定すると RangeError が発生します。

また同じ処理であっても複数の種類のエラーが発生することがあります。 
Number オブジェクトの toFixed メソッドでは、引数に 0 から 100 までの範囲の値しか指定できませんが、それを超える値を指定すると RangeError が発生します。
また数値以外の値に対してこのメソッドを呼び出すと TypeError が発生します。
また整数の数値リテラルに括弧をつけずにこのメソッドを呼び出すと SyntaxError が発生します。

try...catch 文ではどのような種類の例外であってもスローされた例外をキャッチすることができますが、キャッチした例外の種類毎に異なる処理を行うこともできます。

## 例外の種類に応じて実行する処理を分ける
発生した例外の種類毎に実行する処理を分けたい場合、 catch のあとの括弧の中に記述した変数 e に格納されている値を調べて条件分岐を行います。

### try{
###   例外が発生する可能性がある文を記述
###   ・・・
### } catch(e) {
###   if (e instanceof RangeError){
###     // RangeError が発生した場合に実行される処理
###     ・・・
###   } else if (e instanceof TypeError){
###     // TypeError が発生した場合に実行される処理
###     ・・・
###   } else {
###     // 上記以外の例外が発生した場合に実行される処理
###     ・・・
###   }
### }

catch のあとの変数には例外がスローされたときに設定された値が格納されます。
この値を instanceof 演算子を使って RangeError オブジェクトや TypeError オブジェクトと比較することで例外の種類を特定することができます。
